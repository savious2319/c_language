day11

포인터 연산자
	변수 앞에 & 붙이면 주소를 구할 수 있다.
	이렇게 구한 주소에 다시 * 연산을 통해 데이터를 읽어낼 수 있다
	int age = 11;

	&age 주소!!

	int *pAge;
	pAge = &age; //주소값을 저장해 놓고 쓸 수 있다.

	*&age => 결국 age값을 보겠다는 뜻!
	%d, age); -> 11살
	%d, *&age); -> 11살
	%d, *pAge); -> 11살
	%d, *&*pAge) -> 11살
	* -> 영역을 의미한다
	*주소 -> (주소를) 찾아가서 값(데이터)을 읽는다! == 결국은 변수가 된다

포인터 연산
	포인터 - 포인터 -> 정수값 (byte라는 길이)
	120번지 - 100번지 -> 20byte

	포인터 + 1 -> 1칸  (칸은 포인터 타입이 갖고있는 byte수에 따라서
			이동하는 byte가 달라진다)
	예) double *pD;
	    pD + 1 -> (8byte 이동해라) -> 옆칸으로. 옆에 있는 변수로
				     주소값을 이동시켜라
	    int *pInt
	    pInt + 1 -> (4byte 이동해라)

*1) 포인터 인자 전달
	함수 선언
	void fct(int _age , int *pAge)
	{

	}

	fct(age, &age); 호출 // 값, 주소

*2) 동적메모리 할당
->day10일차 pointer09.c부터
	(1) 생성 : memory allocation
		malloc(원하는 byte수)
		malloc(12); 12byte를 만들고, 시작번지를 리턴해라!
		
		char *pCh = (char *)malloc(12); 

		*(pCh + 0) = 'A';
		*(pCh + 1) = 'B';
		scanf("%c", &*(pCh+2)); <--세번째 공간에 입력받고 싶다!

	(2) 소멸 : free(포인터 A)
		포인터 A를  없애는 게 아니라!!!
		포인터A가 갖고 있는 주소로 찾아가서
		그 영역을 지워라


이중 포인터
==================================================
<무작위로 나와서 설명함>

pointer06.c - 송인준
pointer09.c
pointer10.c
pointer12.c 





