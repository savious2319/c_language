#include<stdio.h>
/*
	** 연산자 종류
	최우선 : () [] . ->
	단항	  : + -  !  ~  *  &  ()  ++ -- sizeof()
	산술  :  * / % + -
	쉬프트 : <<  >>
	관계 : <  >  <=  >==  ==  !=
	논리 : &  |  ^  &&  ||
	삼항 : (항1)?(항2) : (항3) -> ?:
	대입 : = += -+ *= /= <<== ....
	(콤마) 도 연사자 이지만, 사용을 잘 안한다!

	1. 최우선 연산자
	   1) () 소괄호 연산자
	     (1) 연산 우선순위 변경
		 (2) 함수 호출 연산자 :  함수 호출 할 때
	   2) [] 대괄호 연산자
	     (1) 배열을 선언하고 난 후, 배열의 한 요소를 호출할 때
		     배열을 선언할 때, 대괄호를 쓰지만, 이때는 연산자가 아니다!
			 선언 이후, 배열의 한 칸을 부르고자 할 때가 연산자이다!
	   3) . 점(period) 연산자
	     (1) 구조체에서 구조체 멤버변수 하나를 지칭할 때 쓰는 연산자이다.
	   4) -> 화살표 연산자
	     (1) 구조체에서 멤버변수를 포인터로 부를 때 사용하는 연산자이다.

		 . 점연산자 : 직접호출
		 -> 화살표 : (포인터를 이용해서) 간접호출


*/
/*
//1. 함수 호출하기

//사용자가 함수를 만들 수 있다. <--printf() puts() scanf()
//그런데 필요에 따라서 우리가 직접 함수를 만들 수 있다. : "사용자 정의 함수"
//만드는 위치는 헤더부하고 body부 사이에..(main함수 위에 만들면 된다)
//만드는 형식은 메인함수 만들듯이 자료형 함수이름 소괄호 {} 로 구성된다.
int getAdd() // <- 함수를 만들 때 사용하는 ()는 "선언 declare" 이라고 한다.
{
	return 5 + 3; //<--8이라는 결과값을 가지고 돌아가!

}
void main()
{
	//사용자가 만든 getAdd 라는 함수를 호출 할 수 있다!!! 이때 사용하는 ()가 연산자이다.

	int getSum = getAdd(); //<---getAdd라는 함수에 다녀와라!!
					       //메모리에 올라간다 <-- "정의 define(=make): 메모리에 실제로 올라갈 때"
	                      // 함수는 선언갖고는 메모리에 올라가지 않고, 48번 라인처럼, 호출을 할 때 비로소
	                       // "선언" 할 때는 마치 주석처럼 글자에 지나지 않는다!

	printf("getAdd() 호출 결과 : %d\n", getSum);


	printf("두 덧셈의 결과값 : %d\n", getAdd() + getAdd()); // 연사자가 4개
	//printf는 헤더파일로 갔다 온다

}
*/
/*
//2. 배열 호출하기
void main()
{
	
	
	int number1; // 변수 선언(x) -> 변수 정의
	int number2;
	int number3;
	
	int number[3]; //배열 정의 이때 []는 형태를 얘기해 주는 선언이다. int가 명령을 내리는 것
	               //즉, 연산자가 아니다!
	// [] 연산자
	number[0] = 100; //배열의 첫번째 0이다 //연산자 2개 (대괄호 1순위 -> = 2순위) 왼 -> 오
	number[1] = 90; // []로 위치를 지정한 후, 데이터를 대입 하게 된다.
	number[2] = 80; // []는 최우선 연산자이기 때문에, 먼저 메모리를 가리키고 나서, 데이터를 대입시키는 순서!

	int total = number[0] + number[1] + number[2];
	printf("총 합 : %d\n", total);
}
*/
///*
//3. . 점 연산자 : 구조체에서 멤버변수를 호출할 때 사용하는 연산자 "멤버 직접호출 연산자"
//                  자바에서도 많이 쓰이는 연산자
//                  구조체변수.멤버변수 -> 구조체 변수가 갖고 있는 멤버중에 "멤버변수"를 호출해라!
// 구조체 : {} 안에 여러 변수를 모아서 관리할 수 있는 자료형
//          *배열은 오로지 한개의 타입만 집합체로 관리할 수 있지만, 구조체는 여러 타입을 묶어서 관리할 수 있다.
//          구조체는 여러 타입을 묶을 수 있기 때문에 대용량 데이터를 처리하는데 유리하다.
//          구조체 안에 구조체, 배열, 기본자료형 등을 다 넣을 수 있는 사용자 정의 자료형이다!
//          구조체 안에 여러 자료형이 있을 때, .을 사용해서 하나씩 하나씩 불러와 데이터를 넣게 된다!

//4. -> 화살표 연산자 (arrow 연산자)
//      구조체변수에 포인터를 사용해 멤버변수를 가리킬 때 사용한다.
//      (*구조체변수).멤버면수 >>>>>> 복잡하고 연사자를 많이 사용했다 그래서... 화살표 연산자로 표현할 수 있다.
//      구조체변수 -> 멤버변수 (나중에 구조체가서 다시 공부해 본다!)

// 구조체 만들기
struct Point{ // <---int, double, char, float 은 기본 자료형, Point는 내가 만든 자료형!!
	int _x;  //멤버변수, x와 y를 만들었다.
	int _y;
};
void main()
{
	int x = 10; //지역변수 local variable
	int y = 20;

	printf("현재 좌표>> x:%d\ty:%d\n", x, y);

	//같은 값을 구조체로도 표현해 보자!
	//구조체 자료형 + 변수; 자료형(struct Point) + 변수(here)
	struct Point here;

	//here 가 변수수나!! 그런데,  here 안에는 here를 구성하는 멤버들이 들어있대~
	//그 멤버들을 멤버 변수라고 부르고,, 그 멤버 변수 중에 하나를 지칭해야 데이터를 대입 시킬 수 있대~
	//멤버변수 하나를 지칭할 때 쓰는 연산자가 바로 . 쩜 연산자이다!!!
	here._x = 100;
	here._y = 200;

	printf("구조체 멤버변수로 출력 현재 좌표>> x:%d\ty:%d\n", here._x, here._y);
	
}
//*/






